// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pageviews.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBrowsersSummaryByDay = `-- name: GetBrowsersSummaryByDay :many
SELECT 
   DISTINCT(browser), 
   COALESCE(COUNT(viewed_at), 0)::bigint AS views,
   COALESCE(COUNT(DISTINCT hashed_ip), 0)::bigint AS unique_visitors
FROM pageviews 
WHERE browser != 'Headless Chrome'
  AND DATE_TRUNC('day', viewed_at)::date >= (NOW() - make_interval(days => $1::int))::date
  AND DATE_TRUNC('day', viewed_at)::date <= NOW()::date
GROUP BY browser
`

type GetBrowsersSummaryByDayRow struct {
	Browser        pgtype.Text `json:"browser"`
	Views          int64       `json:"views"`
	UniqueVisitors int64       `json:"unique_visitors"`
}

func (q *Queries) GetBrowsersSummaryByDay(ctx context.Context, days int32) ([]GetBrowsersSummaryByDayRow, error) {
	rows, err := q.db.Query(ctx, getBrowsersSummaryByDay, days)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBrowsersSummaryByDayRow{}
	for rows.Next() {
		var i GetBrowsersSummaryByDayRow
		if err := rows.Scan(&i.Browser, &i.Views, &i.UniqueVisitors); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBrowsersSummaryForLast24Hours = `-- name: GetBrowsersSummaryForLast24Hours :many
SELECT 
   DISTINCT(browser), 
   COALESCE(COUNT(viewed_at), 0)::bigint AS views,
   COALESCE(COUNT(DISTINCT hashed_ip), 0)::bigint AS unique_visitors
FROM pageviews 
WHERE browser != 'Headless Chrome'
  AND viewed_at >= NOW() - INTERVAL '23 hours'
GROUP BY browser
`

type GetBrowsersSummaryForLast24HoursRow struct {
	Browser        pgtype.Text `json:"browser"`
	Views          int64       `json:"views"`
	UniqueVisitors int64       `json:"unique_visitors"`
}

func (q *Queries) GetBrowsersSummaryForLast24Hours(ctx context.Context) ([]GetBrowsersSummaryForLast24HoursRow, error) {
	rows, err := q.db.Query(ctx, getBrowsersSummaryForLast24Hours)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBrowsersSummaryForLast24HoursRow{}
	for rows.Next() {
		var i GetBrowsersSummaryForLast24HoursRow
		if err := rows.Scan(&i.Browser, &i.Views, &i.UniqueVisitors); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDevicesSummaryByDay = `-- name: GetDevicesSummaryByDay :many
SELECT 
  d::date AS date,
  -- Mobile
  COALESCE(COUNT(p.viewed_at) FILTER (WHERE p.device = 'mobile'), 0)::bigint AS mobile_views,
  COALESCE(COUNT(DISTINCT p.hashed_ip) FILTER (WHERE p.device = 'mobile'), 0)::bigint AS mobile_visitors,
  -- Desktop
  COALESCE(COUNT(p.viewed_at) FILTER (WHERE p.device = 'desktop'), 0)::bigint AS desktop_views,
  COALESCE(COUNT(DISTINCT p.hashed_ip) FILTER (WHERE p.device = 'desktop'), 0)::bigint AS desktop_visitors
FROM generate_series(
    (NOW() - make_interval(days => $1::int))::date,
    NOW()::date,
    '1 day'
) AS d
LEFT JOIN pageviews p
  ON DATE_TRUNC('day', p.viewed_at)::date = d
  AND p.browser != 'Headless Chrome'
GROUP BY d
ORDER BY d
`

type GetDevicesSummaryByDayRow struct {
	Date            pgtype.Date `json:"date"`
	MobileViews     int64       `json:"mobile_views"`
	MobileVisitors  int64       `json:"mobile_visitors"`
	DesktopViews    int64       `json:"desktop_views"`
	DesktopVisitors int64       `json:"desktop_visitors"`
}

func (q *Queries) GetDevicesSummaryByDay(ctx context.Context, days int32) ([]GetDevicesSummaryByDayRow, error) {
	rows, err := q.db.Query(ctx, getDevicesSummaryByDay, days)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDevicesSummaryByDayRow{}
	for rows.Next() {
		var i GetDevicesSummaryByDayRow
		if err := rows.Scan(
			&i.Date,
			&i.MobileViews,
			&i.MobileVisitors,
			&i.DesktopViews,
			&i.DesktopVisitors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDevicesSummaryForLast24Hours = `-- name: GetDevicesSummaryForLast24Hours :many
SELECT 
  h::timestamp AS hour,
  -- Mobile
  COALESCE(COUNT(p.viewed_at) FILTER (WHERE p.device = 'mobile'), 0)::bigint AS mobile_views,
  COALESCE(COUNT(DISTINCT p.hashed_ip) FILTER (WHERE p.device = 'mobile'), 0)::bigint AS mobile_visitors,
  -- Desktop
  COALESCE(COUNT(p.viewed_at) FILTER (WHERE p.device = 'desktop'), 0)::bigint AS desktop_views,
  COALESCE(COUNT(DISTINCT p.hashed_ip) FILTER (WHERE p.device = 'desktop'), 0)::bigint AS desktop_visitors
FROM generate_series(
     date_trunc('hour', NOW() - INTERVAL '23 hours'),
    date_trunc('hour', NOW()),
    '1 hour'
) AS h
LEFT JOIN pageviews p
  ON DATE_TRUNC('hour', p.viewed_at)::timestamp = h
  AND p.browser != 'Headless Chrome'
GROUP BY h
ORDER BY h
`

type GetDevicesSummaryForLast24HoursRow struct {
	Hour            pgtype.Timestamp `json:"hour"`
	MobileViews     int64            `json:"mobile_views"`
	MobileVisitors  int64            `json:"mobile_visitors"`
	DesktopViews    int64            `json:"desktop_views"`
	DesktopVisitors int64            `json:"desktop_visitors"`
}

func (q *Queries) GetDevicesSummaryForLast24Hours(ctx context.Context) ([]GetDevicesSummaryForLast24HoursRow, error) {
	rows, err := q.db.Query(ctx, getDevicesSummaryForLast24Hours)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDevicesSummaryForLast24HoursRow{}
	for rows.Next() {
		var i GetDevicesSummaryForLast24HoursRow
		if err := rows.Scan(
			&i.Hour,
			&i.MobileViews,
			&i.MobileVisitors,
			&i.DesktopViews,
			&i.DesktopVisitors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOSSummaryByDay = `-- name: GetOSSummaryByDay :many
SELECT 
   CASE 
      -- iOS variants
      WHEN os ILIKE '%iPhone OS%' OR os ILIKE '%iOS%' THEN 'iOS'::varchar
      -- Android variants
      WHEN os ILIKE '%Android%' THEN 'Android'::varchar
      -- Windows variants
      WHEN os ILIKE '%Windows%' THEN 'Windows'::varchar
      -- Mac OS variants
      WHEN os ILIKE '%Mac OS%' AND os NOT ILIKE '%iPhone%' THEN 'Mac OS'::varchar
      -- Linux variants
      WHEN os ILIKE '%Linux%' AND os NOT ILIKE '%Android%' THEN 'Linux'::varchar
      -- Chrome OS
      WHEN os ILIKE '%Chrome OS%' THEN 'Chrome OS'::varchar
      -- Keep other OS as-is or mark as Other
      ELSE COALESCE(os, 'Other')::varchar
   END AS os_group,
   COALESCE(COUNT(viewed_at), 0)::bigint AS views,
   COALESCE(COUNT(DISTINCT hashed_ip), 0)::bigint AS unique_visitors
FROM pageviews 
WHERE browser != 'Headless Chrome'
  AND DATE_TRUNC('day', viewed_at)::date >= (NOW() - make_interval(days => $1::int))::date
  AND DATE_TRUNC('day', viewed_at)::date <= NOW()::date
  AND os IS NOT NULL
GROUP BY os_group
`

type GetOSSummaryByDayRow struct {
	OsGroup        string `json:"os_group"`
	Views          int64  `json:"views"`
	UniqueVisitors int64  `json:"unique_visitors"`
}

func (q *Queries) GetOSSummaryByDay(ctx context.Context, days int32) ([]GetOSSummaryByDayRow, error) {
	rows, err := q.db.Query(ctx, getOSSummaryByDay, days)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOSSummaryByDayRow{}
	for rows.Next() {
		var i GetOSSummaryByDayRow
		if err := rows.Scan(&i.OsGroup, &i.Views, &i.UniqueVisitors); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOSSummaryForLast24Hours = `-- name: GetOSSummaryForLast24Hours :many
SELECT 
   CASE 
      -- iOS variants
      WHEN os ILIKE '%iPhone OS%' OR os ILIKE '%iOS%' THEN 'iOS'::varchar
      -- Android variants
      WHEN os ILIKE '%Android%' THEN 'Android'::varchar
      -- Windows variants
      WHEN os ILIKE '%Windows%' THEN 'Windows'::varchar
      -- Mac OS variants
      WHEN os ILIKE '%Mac OS%' AND os NOT ILIKE '%iPhone%' THEN 'Mac OS'::varchar
      -- Linux variants
      WHEN os ILIKE '%Linux%' AND os NOT ILIKE '%Android%' THEN 'Linux'::varchar
      -- Chrome OS
      WHEN os ILIKE '%Chrome OS%' THEN 'Chrome OS'::varchar
      -- Keep other OS as-is or mark as Other
      ELSE COALESCE(os, 'Other')::varchar
   END AS os_group,
   COALESCE(COUNT(viewed_at), 0)::bigint AS views,
   COALESCE(COUNT(DISTINCT hashed_ip), 0)::bigint AS unique_visitors
FROM pageviews 
WHERE browser != 'Headless Chrome'
  AND viewed_at >= NOW() - INTERVAL '23 hours'
  AND os IS NOT NULL
GROUP BY os_group
`

type GetOSSummaryForLast24HoursRow struct {
	OsGroup        string `json:"os_group"`
	Views          int64  `json:"views"`
	UniqueVisitors int64  `json:"unique_visitors"`
}

func (q *Queries) GetOSSummaryForLast24Hours(ctx context.Context) ([]GetOSSummaryForLast24HoursRow, error) {
	rows, err := q.db.Query(ctx, getOSSummaryForLast24Hours)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOSSummaryForLast24HoursRow{}
	for rows.Next() {
		var i GetOSSummaryForLast24HoursRow
		if err := rows.Scan(&i.OsGroup, &i.Views, &i.UniqueVisitors); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPageviewTimeseriesByDay = `-- name: GetPageviewTimeseriesByDay :many
SELECT 
    d::date AS date,
    COALESCE(COUNT(p.viewed_at), 0)::bigint AS views,
    COALESCE(COUNT(DISTINCT p.hashed_ip), 0)::bigint AS unique_visitors
FROM generate_series(
    (NOW() - make_interval(days => $1::int))::date,
    NOW()::date,
    '1 day'
) AS d
LEFT JOIN pageviews p
    ON DATE_TRUNC('day', p.viewed_at)::date = d
    AND p.browser != 'Headless Chrome'
GROUP BY d
ORDER BY d
`

type GetPageviewTimeseriesByDayRow struct {
	Date           pgtype.Date `json:"date"`
	Views          int64       `json:"views"`
	UniqueVisitors int64       `json:"unique_visitors"`
}

func (q *Queries) GetPageviewTimeseriesByDay(ctx context.Context, days int32) ([]GetPageviewTimeseriesByDayRow, error) {
	rows, err := q.db.Query(ctx, getPageviewTimeseriesByDay, days)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPageviewTimeseriesByDayRow{}
	for rows.Next() {
		var i GetPageviewTimeseriesByDayRow
		if err := rows.Scan(&i.Date, &i.Views, &i.UniqueVisitors); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPageviewTimeseriesForLast24Hours = `-- name: GetPageviewTimeseriesForLast24Hours :many
SELECT 
    h::timestamp AS hour,
    COALESCE(COUNT(p.viewed_at), 0)::bigint AS views,
    COALESCE(COUNT(DISTINCT p.hashed_ip), 0)::bigint AS unique_visitors
FROM generate_series(
    date_trunc('hour', NOW() - INTERVAL '23 hours'),
    date_trunc('hour', NOW()),
    '1 hour'
) AS h
LEFT JOIN pageviews p
    ON date_trunc('hour', p.viewed_at) = h
    AND p.browser != 'Headless Chrome'
GROUP BY h
ORDER BY h
`

type GetPageviewTimeseriesForLast24HoursRow struct {
	Hour           pgtype.Timestamp `json:"hour"`
	Views          int64            `json:"views"`
	UniqueVisitors int64            `json:"unique_visitors"`
}

func (q *Queries) GetPageviewTimeseriesForLast24Hours(ctx context.Context) ([]GetPageviewTimeseriesForLast24HoursRow, error) {
	rows, err := q.db.Query(ctx, getPageviewTimeseriesForLast24Hours)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPageviewTimeseriesForLast24HoursRow{}
	for rows.Next() {
		var i GetPageviewTimeseriesForLast24HoursRow
		if err := rows.Scan(&i.Hour, &i.Views, &i.UniqueVisitors); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalViewsAndVisitors = `-- name: GetTotalViewsAndVisitors :one
SELECT COUNT(id) as total_views, COUNT(DISTINCT hashed_ip) as total_visitors
FROM pageviews
`

type GetTotalViewsAndVisitorsRow struct {
	TotalViews    int64 `json:"total_views"`
	TotalVisitors int64 `json:"total_visitors"`
}

func (q *Queries) GetTotalViewsAndVisitors(ctx context.Context) (GetTotalViewsAndVisitorsRow, error) {
	row := q.db.QueryRow(ctx, getTotalViewsAndVisitors)
	var i GetTotalViewsAndVisitorsRow
	err := row.Scan(&i.TotalViews, &i.TotalVisitors)
	return i, err
}

const storePageview = `-- name: StorePageview :exec
INSERT INTO pageviews (pathname, hashed_ip, country, browser, os, device, user_agent, referrer)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type StorePageviewParams struct {
	Pathname  string      `json:"pathname"`
	HashedIp  string      `json:"hashed_ip"`
	Country   pgtype.Text `json:"country"`
	Browser   pgtype.Text `json:"browser"`
	Os        pgtype.Text `json:"os"`
	Device    pgtype.Text `json:"device"`
	UserAgent string      `json:"user_agent"`
	Referrer  pgtype.Text `json:"referrer"`
}

func (q *Queries) StorePageview(ctx context.Context, arg StorePageviewParams) error {
	_, err := q.db.Exec(ctx, storePageview,
		arg.Pathname,
		arg.HashedIp,
		arg.Country,
		arg.Browser,
		arg.Os,
		arg.Device,
		arg.UserAgent,
		arg.Referrer,
	)
	return err
}

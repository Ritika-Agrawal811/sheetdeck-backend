// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cheatsheets.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCheatsheetsByCategoryAndSubcategory = `-- name: CountCheatsheetsByCategoryAndSubcategory :many
SELECT category, subcategory, COUNT(DISTINCT id) AS cheatsheet_count
FROM cheatsheets
GROUP BY category, subcategory
`

type CountCheatsheetsByCategoryAndSubcategoryRow struct {
	Category        Category    `json:"category"`
	Subcategory     Subcategory `json:"subcategory"`
	CheatsheetCount int64       `json:"cheatsheet_count"`
}

func (q *Queries) CountCheatsheetsByCategoryAndSubcategory(ctx context.Context) ([]CountCheatsheetsByCategoryAndSubcategoryRow, error) {
	rows, err := q.db.Query(ctx, countCheatsheetsByCategoryAndSubcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountCheatsheetsByCategoryAndSubcategoryRow{}
	for rows.Next() {
		var i CountCheatsheetsByCategoryAndSubcategoryRow
		if err := rows.Scan(&i.Category, &i.Subcategory, &i.CheatsheetCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createCheatsheet = `-- name: CreateCheatsheet :exec
INSERT INTO cheatsheets (slug, title, category, subcategory, image_url)
VALUES ($1, $2, $3, $4, $5)
`

type CreateCheatsheetParams struct {
	Slug        string      `json:"slug"`
	Title       string      `json:"title"`
	Category    Category    `json:"category"`
	Subcategory Subcategory `json:"subcategory"`
	ImageUrl    pgtype.Text `json:"image_url"`
}

func (q *Queries) CreateCheatsheet(ctx context.Context, arg CreateCheatsheetParams) error {
	_, err := q.db.Exec(ctx, createCheatsheet,
		arg.Slug,
		arg.Title,
		arg.Category,
		arg.Subcategory,
		arg.ImageUrl,
	)
	return err
}

const getCategories = `-- name: GetCategories :many
SELECT unnest(enum_range(NULL::category))::varchar as categories
`

func (q *Queries) GetCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var categories string
		if err := rows.Scan(&categories); err != nil {
			return nil, err
		}
		items = append(items, categories)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryDetails = `-- name: GetCategoryDetails :many
SELECT category, COUNT(DISTINCT id) AS cheatsheet_count, ARRAY_AGG(DISTINCT subcategory)::varchar[] AS subcategories
FROM cheatsheets
GROUP BY category
`

type GetCategoryDetailsRow struct {
	Category        Category `json:"category"`
	CheatsheetCount int64    `json:"cheatsheet_count"`
	Subcategories   []string `json:"subcategories"`
}

func (q *Queries) GetCategoryDetails(ctx context.Context) ([]GetCategoryDetailsRow, error) {
	rows, err := q.db.Query(ctx, getCategoryDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryDetailsRow{}
	for rows.Next() {
		var i GetCategoryDetailsRow
		if err := rows.Scan(&i.Category, &i.CheatsheetCount, &i.Subcategories); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCheatsheetByID = `-- name: GetCheatsheetByID :one
SELECT id, slug, title, category, subcategory, image_url, created_at, updated_at
FROM cheatsheets
WHERE id = $1
`

func (q *Queries) GetCheatsheetByID(ctx context.Context, id pgtype.UUID) (Cheatsheet, error) {
	row := q.db.QueryRow(ctx, getCheatsheetByID, id)
	var i Cheatsheet
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Category,
		&i.Subcategory,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCheatsheetBySlug = `-- name: GetCheatsheetBySlug :one
SELECT id, slug, title, category, subcategory, image_url, created_at, updated_at
FROM cheatsheets
WHERE slug = $1
`

func (q *Queries) GetCheatsheetBySlug(ctx context.Context, slug string) (Cheatsheet, error) {
	row := q.db.QueryRow(ctx, getCheatsheetBySlug, slug)
	var i Cheatsheet
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Category,
		&i.Subcategory,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubcategories = `-- name: GetSubcategories :many
SELECT unnest(enum_range(NULL::subcategory))::varchar as subcategories
`

func (q *Queries) GetSubcategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getSubcategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var subcategories string
		if err := rows.Scan(&subcategories); err != nil {
			return nil, err
		}
		items = append(items, subcategories)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalCheasheetsCount = `-- name: GetTotalCheasheetsCount :one
Select COUNT(id) from cheatsheets
`

func (q *Queries) GetTotalCheasheetsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalCheasheetsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listCheatsheets = `-- name: ListCheatsheets :many
SELECT id, slug, title, category::varchar, subcategory::varchar, image_url, created_at, updated_at
FROM cheatsheets
WHERE ($3::category IS NULL OR category = $3)
  AND ($4::subcategory IS NULL OR subcategory = $4)
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListCheatsheetsParams struct {
	Limit       int32           `json:"limit"`
	Offset      int32           `json:"offset"`
	Category    NullCategory    `json:"category"`
	Subcategory NullSubcategory `json:"subcategory"`
}

type ListCheatsheetsRow struct {
	ID          pgtype.UUID        `json:"id"`
	Slug        string             `json:"slug"`
	Title       string             `json:"title"`
	Category    string             `json:"category"`
	Subcategory string             `json:"subcategory"`
	ImageUrl    pgtype.Text        `json:"image_url"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListCheatsheets(ctx context.Context, arg ListCheatsheetsParams) ([]ListCheatsheetsRow, error) {
	rows, err := q.db.Query(ctx, listCheatsheets,
		arg.Limit,
		arg.Offset,
		arg.Category,
		arg.Subcategory,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCheatsheetsRow{}
	for rows.Next() {
		var i ListCheatsheetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.Category,
			&i.Subcategory,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCheatsheet = `-- name: UpdateCheatsheet :exec
UPDATE cheatsheets
SET slug = COALESCE(NULLIF($1::varchar, ''), slug),
    title = COALESCE(NULLIF($2::text, ''), title),
    category = COALESCE(NULLIF($3, '')::category, category),
    subcategory = COALESCE(NULLIF($4, '')::subcategory, subcategory),
    image_url = COALESCE(NULLIF($5::text, ''), image_url),
    updated_at = NOW()
WHERE id = $6
`

type UpdateCheatsheetParams struct {
	Slug        string      `json:"slug"`
	Title       string      `json:"title"`
	Category    interface{} `json:"category"`
	Subcategory interface{} `json:"subcategory"`
	ImageUrl    string      `json:"image_url"`
	ID          pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateCheatsheet(ctx context.Context, arg UpdateCheatsheetParams) error {
	_, err := q.db.Exec(ctx, updateCheatsheet,
		arg.Slug,
		arg.Title,
		arg.Category,
		arg.Subcategory,
		arg.ImageUrl,
		arg.ID,
	)
	return err
}
